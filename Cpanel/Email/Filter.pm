package Cpanel::Email::Filter;

# cpanel - Cpanel/Email/Filter.pm                  Copyright 2022 cPanel, L.L.C.
#                                                           All rights reserved.
# copyright@cpanel.net                                         http://cpanel.net
# This code is subject to the cPanel license. Unauthorized copying is prohibited

use strict;

use Cpanel                           ();
use Cpanel::Context                  ();
use Cpanel::LocaleString             ();
use Cpanel::Rand::Get                ();
use Cpanel::CachedDataStore          ();
use Cpanel::Email::SuspendedIncoming ();
use Cpanel::Encoder::Tiny            ();
use Cpanel::Locale                   ();
use Cpanel::LoadModule               ();
use Cpanel::PwCache                  ();
use Cpanel::SafeDir::MK              ();
use Cpanel::SafeFile                 ();
use Cpanel::LoadModule               ();
use Cpanel::Debug                    ();
use Cpanel::ConfigFiles              ();

use Cpanel::Validate::FilesystemNodeName ();

our $SAVE_PERMS = '660';

our $VERSION = 2.2;

our $EXIM_FILTER_HEADER = <<END;
# Exim filter - auto-generated by cPanel.
#
# Do not manually edit this file; instead, use cPanel APIs to manipulate
# email filters. MANUAL CHANGES TO THIS FILE WILL BE OVERWRITTEN.
#
END

sub _SUSPENDED_PHRASE {
    return Cpanel::LocaleString->new('This email account’s owner has suspended delivery for the account.');
}

#NB: $account is optional
sub _generate_exim_filter_header {
    my ( $fstore, $stordir, $account ) = @_;

    my $exim_filter = $EXIM_FILTER_HEADER;
    if ( $account && Cpanel::Email::SuspendedIncoming->is_on($account) ) {
        my $locale  = Cpanel::Locale->get_handle();
        my $message = _SUSPENDED_PHRASE()->to_string();
        if ( $locale->get_language_tag() ne 'en' ) {
            my $en_message = _SUSPENDED_PHRASE()->to_en_string();
            if ( $en_message ne $message ) {
                $message .= " $en_message";
            }
        }

        #Exim’s “fail” filter command can only accept US-ASCII text strings.
        Cpanel::LoadModule::load_perl_module('Cpanel::UTF8::Strict');
        Cpanel::LoadModule::load_perl_module('Text::Unidecode');
        Cpanel::LoadModule::load_perl_module('Cpanel::Encoder::Exim');
        $message = Text::Unidecode::unidecode( Cpanel::UTF8::Strict::decode($message) );

        $exim_filter .= "# SUSPEND RECEPTION OF NEW MESSAGES\n";
        $exim_filter .= sprintf qq<fail %s\n>, Cpanel::Encoder::Exim::encode_string_literal($message);
    }
    else {
        # Generate an empty file since we can skip processing it when there is nothing to filter
        return '' if !@{ $fstore->{'filter'} } && !$fstore->{'max_allowed_spam_score'};
    }

    $exim_filter .= "\nheaders charset \"UTF-8\"\n";
    $exim_filter .= "\nif not first_delivery and error_message then finish endif\n\n";
    return $exim_filter;
}

sub _process_rules {
    my ($filter)    = @_;
    my $exim_filter = '';
    my $previousopt = 'or';
    my $rulenum     = 0;
    Cpanel::LoadModule::load_perl_module('Cpanel::Encoder::Exim');
    foreach my $rule ( @{ $filter->{'rules'} } ) {
        $rulenum++;

        $exim_filter .= ' ';

        if ( $rulenum != 1 ) {
            $exim_filter .= $previousopt . ' ';
        }

        $previousopt = $rule->{'opt'};

        if ( $rule->{'match'} =~ m/(?:above|below)/ ) {

            #int safety checks to pervent filter errors from missing or negative header
            $exim_filter .= '(' . $rule->{'part'} . ' matches \N^-?\d+$\N and ';
        }
        $exim_filter .= $rule->{'part'} . ' ';
        if ( $rule->{'part'} =~ m/^foranyaddress/ ) {
            $exim_filter .= '( $thisaddress ';
        }
        $exim_filter .= $rule->{'match'};

        $exim_filter .= q{ } . Cpanel::Encoder::Exim::encode_string_literal( $rule->{'val'} );

        if ( $rule->{'part'} =~ m/^foranyaddress/ ) {
            $exim_filter .= ' ) ';
        }

        if ( $rule->{'match'} =~ m/(?:above|below)/ ) {
            $exim_filter .= ')';
        }
        $exim_filter .= "\n";
    }
    return $exim_filter;
}

#NB: $account is optional
sub _generate_exim_filter_string {
    my ( $fstore, $stordir, $account ) = @_;

    my $exim_filter      = _generate_exim_filter_header( $fstore, $stordir, $account );
    my $delivery_account = $account || $Cpanel::user || Cpanel::PwCache::getusername();

    foreach my $filter ( @{ $fstore->{'filter'} } ) {
        next unless _filter_is_enabled($filter);
        if ( !$filter->{'rules'} )                                           { next; }
        if ( ref $filter->{'rules'} eq 'ARRAY' && !@{ $filter->{'rules'} } ) { next; }                                          #handle empty rulesets
        if ( ref $filter->{'rules'} ne 'ARRAY' )                             { $filter->{'rules'} = [ $filter->{'rules'} ]; }

        $exim_filter .= '#' . $filter->{'filtername'} . "\n";
        $exim_filter .= "if\n";
        $exim_filter .= _process_rules($filter);
        $exim_filter .= "then\n";
        if ( ref $filter->{'actions'} ne 'ARRAY' ) {
            $filter->{'actions'} = [ $filter->{'actions'} ];
        }
        my $actionct = 0;
        foreach my $action ( @{ $filter->{'actions'} } ) {
            $actionct++;
            if ( $action->{'action'} eq 'save' && $action->{'dest'} =~ m/^\"?\|/ ) {

                #they really wanted to pipe it somewhere
                $action->{'action'} = 'pipe';
                my $pipedest = $action->{'dest'};
                $pipedest =~ s/^\"|\"$//g;
                $pipedest =~ s/^\|//g;
                $pipedest =~ s/^\s+|\s+$//g;
                $action->{'dest'} = $pipedest;
            }

            if ( $action->{'action'} eq 'fail' ) {
                $exim_filter .= qq{ if error_message then save "/dev/null" $SAVE_PERMS else};
            }

            if ( $action->{'dest'} ) {
                my $realdest = _convert_exim_filter_dest_to_path( $action, $stordir );
                my ( $subaddress, $subuser_domain, $subuser ) = _get_filter_sanitized_subaddress_and_subuser_info_from_path( $realdest, $stordir );

                # If we can convert the path to a subaddress we can deliver over
                # lmtp and avoid the need to use dovecot-lda which is slower then lmtp
                if ( $subaddress && $action->{'action'} eq 'save' ) {
                    if ( length $subuser_domain && length $subuser ) {
                        $exim_filter .= ' deliver ' . _escape_exim_string( '"' . $subuser . '+' . $subaddress . '"@' . $subuser_domain );
                    }
                    else {
                        # The local_part+$subaddress needs to be quoted to be able to handle spaces in subaddresses
                        # and the whole thing needs to be quoted for syntax in the filter file
                        if ( $delivery_account =~ tr{@}{} ) {
                            $exim_filter .= ' deliver ' . _escape_exim_string( '"$local_part+' . $subaddress . '"@$domain' );
                        }
                        else {
                            # If the account is a localuser we must not include a domain to avoid a loop
                            $exim_filter .= ' deliver ' . _escape_exim_string( '"' . $delivery_account . '+' . $subaddress . '"' );
                        }
                    }
                }
                elsif ( length $subuser_domain && length $subuser && $action->{'action'} eq 'save' ) {
                    $exim_filter .= ' deliver ' . _escape_exim_string( '"' . $subuser . '"@' . $subuser_domain );
                }
                else {
                    my $escaped_realdest = _escape_exim_string($realdest);
                    $exim_filter .= ' ' . $action->{'action'};
                    $exim_filter .= q{ } . $escaped_realdest;
                    if ( $action->{'action'} eq 'save' ) {
                        $exim_filter .= ' ' . $SAVE_PERMS;
                    }
                }
            }
            else {
                $exim_filter .= ' ' . $action->{'action'};
            }

            if ( $action->{'action'} eq 'fail' ) {
                $exim_filter .= ' endif';
            }

            $exim_filter .= "\n";
        }
        $exim_filter .= "endif\n\n";
    }

    #Process the spam filter last. This allows the user to do things like
    #whitelist messages that match specific patterns. (It also matches the
    #behavior of adding the cpaccount-general filter.)
    if ( $fstore->{'max_allowed_spam_score'} ) {
        Cpanel::LoadModule::load_perl_module('Cpanel::Email::Filter::Spam');
        $exim_filter .= Cpanel::Email::Filter::Spam::generate_spam_filter_for_score( $fstore->{'max_allowed_spam_score'} );
    }

    return $exim_filter;
}

sub _get_filter_sanitized_subaddress_and_subuser_info_from_path {
    my ( $path, $stordir ) = @_;

    my ( $subaddress, $domain, $subuser ) = get_subaddress_and_subuser_info_from_dest_path( $path, $stordir );

    # Stripping the characters is better at this stage for backwards compat and filter regeneration
    $subaddress = _strip_bad_subaddress_characters($subaddress) if length $subaddress;

    return ( $subaddress, $domain, $subuser );
}

sub get_filters {
    my ($account) = @_;

    my $storefile = _fetchfilterstore($account);
    if ( ( !$account || $account eq '' ) && !-e $storefile && -e $Cpanel::homedir . '/.filter' ) {
        _convertfilter();
    }

    return _fetchfilter($storefile);

}

sub countfilters {
    my $fstore = get_filters();

    return 0 if !$fstore || !ref $fstore || !ref $fstore->{'filter'};
    return scalar @{ $fstore->{'filter'} };
}

sub get_subaddress_and_subuser_info_from_dest_path {
    my ( $path, $stordir ) = @_;

    Cpanel::Context::must_be_list();

    if ( $path =~ s{^\Q$stordir\E}{} ) {

        # path might be /home/user/mail/domain.tld/subuser/.folder.sub folder
        # We can assume that the directory after mail will be a domain if
        # it's followed by another directory that doesnt begin with a '.'
        $path =~ s{^/*([^/.]+\.[^/]+)/([^/.][^/]*)/*}{/};
        my $domain  = $1;
        my $subuser = $2;

        if ( $path =~ m{^/*\.+(.*)/?$} ) {
            my $subaddress = $1;
            $subaddress = normalize_subaddress($subaddress);

            return ( $subaddress, $domain, $subuser );
        }
        elsif ( length $domain && length $subuser ) {
            return ( undef, $domain, $subuser );
        }
    }

    return;

}

sub maildir_subaddress_contains_invalid_characters {
    my ($subaddress) = @_;

    return 1 if $subaddress =~ tr{\@\$"}{};       # tr{} is faster if you have 3 index but slower if you have 1 or 2
    return 1 if index( $subaddress, '~' ) == 0;

    # in maildir the subaddress maps to a single directory so we need to validate it as such
    return 1 if !Cpanel::Validate::FilesystemNodeName::is_valid($subaddress);

    return 0;
}

sub mdbox_subaddress_contains_invalid_characters {
    my ($subaddress) = @_;

    return 1 if $subaddress =~ tr{\@\$"}{};       # tr{} is faster if you have 3 index but slower if you have 1 or 2
    return 1 if index( $subaddress, '~' ) == 0;

    # in mdbox the subaddress is divided into separate directories, so we need to validate it in parts
    return 1 if grep { !Cpanel::Validate::FilesystemNodeName::is_valid($_) } split( /\./, $subaddress );

    return 0;
}

sub _strip_bad_subaddress_characters {
    my ($subaddress) = @_;

    $subaddress =~ tr/@\$\"\0//d;
    $subaddress = substr( $subaddress, 1, length($subaddress) ) if substr( $subaddress, 0, 1 ) eq '~';

    return $subaddress;
}

sub normalize_subaddress {
    my ($subaddress) = @_;

    # Don't end in a '/', otherwise it'll be turned into a '.'
    $subaddress = substr( $subaddress, 0, -1 ) if substr( $subaddress, -1, 1 ) eq '/';

    # The seperator for dovecot is '.'
    $subaddress =~ tr{/}{\.};
    $subaddress =~ s{\.+}{\.}g;

    # Remove a leading '.' since it's assumed in delivery
    $subaddress = substr( $subaddress, 1 ) if substr( $subaddress, 0, 1 ) eq '.';

    return $subaddress;
}

sub parse_subaddress_deliver_destination {
    my ($dest) = @_;

    $dest =~ s/^\s*['"]//g;
    $dest =~ s/['"]\s*$//g;

    my ( $user, $subaddress, $domain );

    if ( index( $dest, '@' ) > -1 ) {
        ( $user, $domain ) = split( /@/, $dest, 2 );
        $user   =~ s/['"]\s*$//g;
        $domain =~ s/['"]\s*$//g;
    }
    else {
        $user = $dest;
    }

    if ( index( $user, '+' ) > -1 ) {
        ( $user, $subaddress ) = split( /\+/, $user, 2 );
    }

    return ( $user, $subaddress, $domain );
}

sub _convert_exim_filter_dest_to_path {
    my ( $action, $stordir ) = @_;

    $stordir =~ s{/+}{/};
    $stordir =~ s{/$}{};
    my $realdest;

    if ( $action->{'action'} eq 'save' && $action->{'dest'} !~ /^(?:\/|\$home\/)/ ) {
        my $safedest = $action->{'dest'};
        $safedest =~ s/\/$//g;
        $safedest =~ s{/+}{/}g;

        my @DL     = split( /\//, $safedest );
        my $folder = pop(@DL);
        $folder =~ s/^\.//g;                                    #maildir needs this
        $folder = '.' . $folder;                                # maildir needs this
        push @DL, $folder;
        @DL       = grep( !/^\.\.$/, @DL );
        $realdest = $stordir . '/' . join( '/', @DL ) . '/';    #maildir needs a trailing /
    }
    else {
        $realdest = $action->{'dest'};
        if ( $action->{'action'} eq 'save' ) {
            $realdest =~ s{/+}{/}g;
            $realdest =~ s{/$}{}g;
            $realdest =~ s{/INBOX$}{}g;
            if ( $realdest ne '/dev/null' ) {
                $realdest .= '/';    #maildir needs this
            }

            # Fix up
            #     $home/mail/.DOMAIN.TLD/SUBUSER/.FOLDER
            #     =>
            #     $home/mail/DOMAIN.TLD/SUBUSER/.FOLDER
            $realdest =~ s{^\$home/mail/\.([^\/]+)(?=\/[^\.\/]+\/\.)}{\$home/mail/$1};

        }
    }

    return $realdest;
}

sub _escape_exim_string {
    my ($string_to_escape) = @_;

    my $canary_length        = 128;
    my $allowed_random_chars = [ 0 .. 9, 'A' .. 'Z', 'a' .. 'z' ];

    # Protect $home, $local_part, and $domain from being encoded
    my @allowed_variables = ( 'home', 'local_part', 'domain' );

    my %protected_variables = (
        map {

            '$' . $_ => Cpanel::Rand::Get::getranddata( $canary_length, $allowed_random_chars )
        } @allowed_variables
    );

    my $protected_regex              = join( '|', map { quotemeta($_) } keys %protected_variables );
    my %reversed_protected_variables = reverse %protected_variables;
    my $reversed_protected_regex     = join( '|', map { quotemeta($_) } keys %reversed_protected_variables );

    if ( $string_to_escape =~ m{($reversed_protected_regex)} ) {

        # If this happens we somehow got bad random data
        # This should be about a 62**128 == 2.66769549741243e+229 chance
        # of this happening.  This is unlikely to happen for the forseeable
        # remaining time that the universe can exist.
        die "The string to escape “$string_to_escape”, somehow managed to contain one of our random canary strings: “$reversed_protected_regex”.";
    }

    Cpanel::LoadModule::load_perl_module('Cpanel::Encoder::Exim');
    $string_to_escape =~ s{($protected_regex)}{$protected_variables{$1}}g;
    $string_to_escape = Cpanel::Encoder::Exim::encode_string_literal($string_to_escape);
    $string_to_escape =~ s{($reversed_protected_regex)}{$reversed_protected_variables{$1}}g;

    return $string_to_escape;
}

sub _store_exim_filter {
    my $account = shift;
    my $fstore  = shift;
    if ( defined $Cpanel::appname && $Cpanel::appname eq 'webmail' ) {

        #
        # SECURITY: Do not let the webmail user change anything but their own account
        #

        $account = $Cpanel::authuser;
    }

    my $stordir     = _compute_exim_filter_stordir($account);
    my $exim_filter = _generate_exim_filter_string( $fstore, $stordir, $account );

    if ( !-e $Cpanel::homedir . '/tmp' ) {
        Cpanel::SafeDir::MK::safemkdir( $Cpanel::homedir . '/tmp', '0755' );
    }

    Cpanel::LoadModule::load_perl_module('Cpanel::SafeRun::Object');
    my $run = Cpanel::SafeRun::Object->new(
        'program' => '/usr/sbin/sendmail',
        'stdin'   => $exim_filter,
        'args'    => [ '-bF', '/dev/stdin' ],
    );
    my $result = $run->stdout();

    if ( $result =~ m/^Filter error:/mg ) {
        return ( 0, $result . '--' . "\n" . $exim_filter );
    }

    if ( !$account ) {
        my @unchanged_domains;
        my @changed_domains;
        my @error_domains;
        foreach my $domain (@Cpanel::DOMAINS) {
            my $targetfile = "$Cpanel::ConfigFiles::VFILTERS_DIR/$domain";

            if ( !-w $targetfile ) {
                push @error_domains,
                  {
                    domain      => $domain,
                    filter_file => $targetfile,
                    is_file     => -f _ ? 1 : 0,
                  };
                next;
            }

            ## FIXME: is there a chmod or chown missing here?
            ##   see ::MailTools::_handle_etc_vfilter_contents
            # users shouldn't have write permissions to /etc/vfilters so, skip the dotlock as it'll error
            if ( _slurp_out( $targetfile, \$exim_filter, skip_dot_lock_if_not_root => 1 ) ) {
                push @changed_domains, $domain;
            }
            else {
                push @unchanged_domains, $domain;
            }
        }

        if ( @unchanged_domains || @error_domains ) {
            my @messages;
            if (@unchanged_domains) {
                push @messages, 'PARTIAL FAILURE:';
                push @messages, "These filters were not updated: " . join( ', ', @unchanged_domains ) . q{.};
            }
            if (@error_domains) {
                push @messages, map {
                    my $msg;
                    if ( !$_->{'is_file'} ) {
                        $msg = "$_->{'domain'}’s filter file ($_->{'filter_file'}) does not exist.";
                    }
                    else {
                        $msg = "$_->{'domain'}’s filter file ($_->{'filter_file'}) is not writeable.";
                    }
                    "$msg This filter cannot be saved.";
                } @error_domains;
            }

            Cpanel::Debug::log_warn( join( "\n", @messages ) );
            return ( @changed_domains ? 1 : 0, join( q{ }, @messages ), \@messages );
        }
    }
    else {
        my $targetfile = _get_filterfile_byaccount($account);
        if ( !$targetfile ) {
            return ( 0, "No filter file for $account exists." );
        }
        if ( !_slurp_out( $targetfile, \$exim_filter ) ) {
            return ( 0, "Filter file $targetfile could not be updated." );
        }
    }

    return ( 1, 'Filter Saved.' );

}

sub _slurp_out {
    my ( $file, $refdata, %opts ) = @_;

    my $sf;
    if ( !keys %opts || !$opts{skip_dot_lock_if_not_root} ) {
        $sf = Cpanel::SafeFile::safeopen( \*SLR, '>', $file );
    }
    else {
        # Users can open their own files, but they shouldn't have write perms on the dir so the .lock file will error
        $sf = Cpanel::SafeFile::safeopen_skip_dotlock_if_not_root( \*SLR, '>', $file );
    }

    if ( !$sf ) {
        Cpanel::Debug::log_warn("Could not write to $file: $!");
        return;
    }
    my $status = 1;
    $status &&= print SLR $$refdata;
    $status &&= Cpanel::SafeFile::safeclose( \*SLR, $sf );
    return $status;
}

sub _get_filterfile {
    my ( $user, $homedir, $account ) = @_;
    $homedir //= '';
    my $filterdir = (
        $account && $account =~ tr/@//
        ? do {
            my ( $user, $domain ) = split( /\@/, $account );
            $user   //= '';
            $domain //= '';
            "$homedir/etc/$domain/$user";
          }
        : defined $account && $account eq $user ? "$homedir/etc"
        : "$homedir/.cpanel"

    );

    if ( !-e $filterdir ) {

        # Called by admin binary, so create as correct user
        Cpanel::LoadModule::load_perl_module('Cpanel::SafeDir::MKAsUser');
        Cpanel::SafeDir::MKAsUser::safemkdir_as_user( $user, $filterdir );
    }
    return "$filterdir/filter";
}

sub _get_filterfile_byaccount {
    my $account = shift;
    return _get_filterfile( $Cpanel::user, $Cpanel::homedir, $account );
}

# For calling from Cpanel::MailTools::setupusermaildomainforward which is called by WHM and can't use the $Cpanel:: globals.
sub _get_filterfile_by_user_from_whm {
    my ($user) = @_;

    return if !$user;
    my $homedir = Cpanel::PwCache::gethomedir($user);
    return _get_filterfile( $user, $homedir );
}

# For calling from Cpanel::MailTools::setupusermaildomainforward which is called by WHM and can't use the $Cpanel:: globals.
sub fetchfilterstore_by_user_from_whm {
    my ($user) = @_;
    my $file = _get_filterfile_by_user_from_whm($user);

    return if !$file;

    return $file . '.yaml';
}

# For calling from Cpanel::MailTools::setupusermaildomainforward which is called by WHM and can't use the $Cpanel:: globals.
## note: this computes the string literal used within the Exim filter file; the
##   use of single quotes around an otherwise undeclared $home variable is intentional
sub compute_exim_filter_stordir_from_whm {
    return '$home/mail/';    # case 53248: do not use hard coded home directories
}

sub remove_filter_give_indices {
    my $fstore   = shift;
    my $rulename = shift || '';
    my $filter   = $fstore->{'filter'};
    my @removed;
    if ($filter) {
        for my $i ( reverse( 0 .. $#$filter ) ) {
            if ( $filter->[$i]{'filtername'} eq $rulename ) {
                splice( @{$filter}, $i, 1 );
                push @removed, $i;
            }
        }
    }

    return reverse @removed;
}

sub _removefilter {
    my $removed = @{ [ remove_filter_give_indices(@_) ] };
    if ( $removed && $removed =~ m/^\d+$/ ) {
        return 1;
    }
    else {
        return 0;
    }
}

#removes the first occurrence of the given $rulename and returns it
sub deletefilter {
    my $fstore   = shift;
    my $rulename = shift;
    if ( $fstore->{'filter'} ) {
        for my $i ( 0 .. $#{ $fstore->{'filter'} } ) {
            if ( $fstore->{'filter'}->[$i]->{'filtername'} eq $rulename ) {
                return splice( @{ $fstore->{'filter'} }, $i, 1 );
            }
        }
    }
    return;
}

sub _loadfilter {
    my $fstore   = shift;
    my $rulename = shift;

    my $filter = _selectfilter( $fstore, $rulename );
    if ($filter) {
        foreach my $key ( 'rules', 'actions' ) {
            if ( $filter->{$key} ) {
                if ( ref $filter->{$key} ne 'ARRAY' ) {
                    $filter->{$key} = [ $filter->{$key} ];
                }
                for ( my $i = 0; $i <= $#{ $filter->{$key} }; $i++ ) {
                    ${ $filter->{$key} }[$i]->{'number'} = ( $i + 1 );
                }
            }
        }
    }
    return $filter;
}

sub _selectfilter {
    my $fstore   = shift;
    my $rulename = shift;

    if ( $fstore->{'filter'} ) {
        foreach my $i ( 0 .. $#{ $fstore->{'filter'} } ) {
            if ( ${ $fstore->{'filter'} }[$i]->{'filtername'} eq $rulename ) {
                return ${ $fstore->{'filter'} }[$i];
            }
        }
    }
}

sub _fetchfilter {
    my $storefile = shift;

    # Usage is safe since we always run as a user, and the user owns the dir
    my $fstore = Cpanel::CachedDataStore::fetch_ref($storefile);
    if ( $fstore->{'filter'} && ref $fstore->{'filter'} ne 'ARRAY' ) {
        $fstore->{'filter'} = [ $fstore->{'filter'} ];
    }

    # set special attributes for interface usage
    foreach my $filter ( @{ $fstore->{'filter'} } ) {
        $filter->{enabled} = _filter_is_enabled($filter) ? 1 : 0;
        if ( $filter->{'actions'} && ref $filter->{'actions'} eq 'ARRAY' ) {
            foreach my $action ( @{ $filter->{'actions'} } ) {

                # We used to store the whole homedir, we need to set this to $home
                # so it works after transfer
                if ( $action->{'dest'} && $action->{'dest'} =~ m{^/} ) {
                    $action->{'dest'} =~ s/^\Q$Cpanel::homedir\E/\$home/g    if length $Cpanel::homedir;
                    $action->{'dest'} =~ s/^\Q$Cpanel::abshomedir\E/\$home/g if length $Cpanel::abshomedir;
                    $action->{'dest'} =~ s{/+}{/}g;
                }
            }
        }
    }

    return $fstore;
}

sub _fetchfilterstore {
    my $account = shift;
    return _get_filterfile_byaccount($account) . '.yaml';
}

## note: this computes the string literal used within the Exim filter file; the
##   use of single quotes around an otherwise undeclared $home variable is intentional
sub _compute_exim_filter_stordir {
    my ($account) = @_;
    my $stordir;
    if ( !$account || $account eq $Cpanel::user ) {
        $stordir = '$home/mail/';    # case 53248: do not use hard coded home directories
    }
    else {
        my ( $user, $domain ) = split( /\@/, $account, 2 );
        $stordir = '$home/mail/' . $domain . '/' . $user . '/';    # case 53248: do not use hard coded home directories
    }
    return $stordir;
}

sub _convertfilter {
    my $fstore;
    my $rulenum = 0;
    my $flock   = Cpanel::SafeFile::safeopen( \*FC, '<', $Cpanel::homedir . '/.filter' );

    if ( !$flock ) {
        Cpanel::Debug::log_warn("Could not read from $Cpanel::homedir/.filter");
        return;
    }
    while (<FC>) {
        $rulenum++;
        s/[\n\t]|^\s|\s$//g;
        my ( $fl, $dest ) = split /\+\+\+\+\+\+\+(?![+"])/;
        if ( !length $dest ) {
            $dest = '/dev/null';
        }
        $fl =~ m/^(\S+)\s+([^\"]+)\"([^\"]+)/;
        my $part  = $1;
        my $match = $2;
        my $val   = $3;
        my $opt   = 'or';
        my $newfilter;
        my $dval = $val;

        $dval  =~ s/\s+$//g if $dval;
        $match =~ s/\s*$//g if $dval;

        if ($part) {
            push @{ $newfilter->{'rules'} },
              {
                'part'  => $part,
                'match' => $match,
                'val'   => $val,
                'opt'   => $opt,
              };
        }
        if ($dest) {
            my $action = 'save';
            require HTML::Entities;
            $dest = HTML::Entities::decode_entities($dest);
            $dest =~ s/^[\"\']*|[\"\']$//g;
            push @{ $newfilter->{'actions'} },
              {
                'action' => $action,
                'dest'   => $dest,
              };
        }

        for ( $part, $match, $dval ) {
            $_ = q{} if !length;
        }

        $newfilter->{'filtername'} = Cpanel::Encoder::Tiny::safe_html_encode_str("Converted Rule : $part $match $dval");
        push @{ $fstore->{'filter'} }, $newfilter;
    }
    Cpanel::SafeFile::safeclose( \*FC, $flock );

    my $storefile = _fetchfilterstore();
    $fstore->{'version'} = $VERSION;
    return Cpanel::CachedDataStore::store_ref( $storefile, $fstore );
}

sub _filter_is_enabled {
    my $filter = shift;

    return unless $filter;
    return unless ref $filter eq ref {};

    # if no key 'enabled' defined => filter is enabled ( old generated files )
    return 1 unless exists $filter->{enabled};

    # enabled has a false value
    return 0 if !defined $filter->{enabled};                                     #  but exists
    return 0 if lc $filter->{enabled} eq 'false' || $filter->{enabled} eq '0';

    # in all other cases the filter is enabled
    return 1;
}

1;
