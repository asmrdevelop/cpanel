package Cpanel::Config::CpUser::MigrationData;

# cpanel - Cpanel/Config/CpUser/MigrationData.pm   Copyright 2022 cPanel, L.L.C.
#                                                           All rights reserved.
# copyright@cpanel.net                                         http://cpanel.net
# This code is subject to the cPanel license. Unauthorized copying is prohibited

use cPstrict;

use Carp         ();
use Scalar::Util ();

use Cpanel::UUID         ();
use Cpanel::OSSys::Env   ();
use Cpanel::Server::Type ();

=head1 NAME

Cpanel::Config::CpUser::MigrationData - Constants and functions related to hosting migration data for analytics

=head1 SYNOPSIS

    use Cpanel::Config::CpUser::MigrationData ();

    my $cpuser_data_hr = { [...] };

    Cpanel::Config::CpUser::MigrationData::update_cpuser_data_hr( $cpuser_data_hr, { 'new_account' => 1 } );

=head1 CONSTANTS

The following string constants contain the known cpuser data key names which should be used in other code that is referencing this data.
The descriptions apply to the cpuser data being referenced by the named key, not the constant.

=over

=item B<KEY_UUID> - String

The UUID of the account.

B<NOTE:> It is expected that the UUID may naturally become duplicated, such as
by backup/restore or account transfers, but it should initially be unique per
account. Do not cache or otherwise re-use the data provided by this module for
batched user creation or updates.

=item B<KEY_UUID_ADDED_AT_ACCOUNT_CREATION> - Boolean

C<1> if the UUID and the other cpuser data generated by this module were added at the time of the account's creation, C<0> otherwise.

=item B<KEY_TRANSFERRED_OR_RESTORED> - Numeric

Starts at C<0> when first added to an account and is incremented by C<1> at the destination of the next transfer or restore from backup.

=item B<KEY_INITIAL_SERVER_ENV_TYPE> - String

The licensed server environment type present at the time the data was generated (see Cpanel::CpKeyClt::EnvType).

=item B<KEY_INITIAL_SERVER_LICENSE_TYPE> - Numeric

The type of server license present at the time the data was generated.
At this time this is simply the licensed user count (0 is unlimited).

=back

=cut

use constant {
    KEY_UUID                           => 'UUID',
    KEY_UUID_ADDED_AT_ACCOUNT_CREATION => 'UUID_ADDED_AT_ACCOUNT_CREATION',
    KEY_TRANSFERRED_OR_RESTORED        => 'TRANSFERRED_OR_RESTORED',
    KEY_INITIAL_SERVER_ENV_TYPE        => 'INITIAL_SERVER_ENV_TYPE',
    KEY_INITIAL_SERVER_LICENSE_TYPE    => 'INITIAL_SERVER_LICENSE_TYPE',
};

=head1 FUNCTIONS

=head2 update_cpuser_data_hr ($cpuser_data_hr, $opts_hr)

Performs an in-place update of a cpuser data hashref.

Named options passed in via optional hashref:

=over

=item * C<new_account> - Boolean (optional)

Set true to generate the data for a new account.
This option is mutually exclusive with C<is_transfer_or_restore>.

=item * C<is_transfer_or_restore> - Boolean (optional)

Set true if this is being called during a transfer or restore procedure.
This option is mutually exclusive with C<new_account>.

=back

=cut

sub update_cpuser_data_hr ( $cpuser_hr, $opts_hr = {} ) {

    # The cpuser hashref may be blessed and that's fine.
    my $cpuser_reftype = Scalar::Util::reftype($cpuser_hr) || 'not-a-ref';
    if ( $cpuser_reftype ne 'HASH' ) {
        Carp::croak("cpuser_hr is not a hashref: $cpuser_reftype");
    }

    my ( $new_account, $is_restore ) = _process_opts($opts_hr);

    if ( !$cpuser_hr->{ KEY_UUID() } ) {
        my $add_hr = generate_cpuser_data_hr($opts_hr);
        foreach my $key ( keys %{$add_hr} ) {
            $cpuser_hr->{$key} = $add_hr->{$key};
        }
        return;
    }

    if ($is_restore) {
        if (   Scalar::Util::looks_like_number( $cpuser_hr->{ KEY_TRANSFERRED_OR_RESTORED() } )
            && $cpuser_hr->{ KEY_TRANSFERRED_OR_RESTORED() } == int( $cpuser_hr->{ KEY_TRANSFERRED_OR_RESTORED() } )
            && $cpuser_hr->{ KEY_TRANSFERRED_OR_RESTORED() } >= 0 ) {
            ++$cpuser_hr->{ KEY_TRANSFERRED_OR_RESTORED() };
        }
        else {
            $cpuser_hr->{ KEY_TRANSFERRED_OR_RESTORED() } = 0;
        }
    }

    return;
}

=head2 generate_cpuser_data_hr ($opts_hr)

Generates a hashref containing a new set of cpuser migration data, for creating a new account or updating an existing account.
If you're already working with cpuser data stored in a simple hashref then consider using L</update_cpuser_data_hr> instead.

Options: Same as L</update_cpuser_data_hr>.

=cut

sub generate_cpuser_data_hr ( $opts_hr = {} ) {
    my ( $new_account, $is_restore ) = _process_opts($opts_hr);

    # Even if this is being called during a transfer/restore,
    # TRANSFERRED_OR_RESTORED should be 0 the first time the data is added.
    return {
        KEY_UUID()                           => Cpanel::UUID::random_uuid(),
        KEY_UUID_ADDED_AT_ACCOUNT_CREATION() => $new_account ? 1 : 0,
        KEY_TRANSFERRED_OR_RESTORED()        => 0,
        KEY_INITIAL_SERVER_ENV_TYPE()        => Cpanel::OSSys::Env::get_envtype(),
        KEY_INITIAL_SERVER_LICENSE_TYPE()    => Cpanel::Server::Type::get_max_users(),
    };
}

sub _process_opts ($input_hr) {
    if ( ref $input_hr ne 'HASH' ) {
        Carp::croak( 'opts input is not a hashref: ' . ( ref $input_hr ? ref $input_hr : 'EMPTY' ) );
    }

    my (
        $new_account,
        $is_restore
      )
      = delete local @{$input_hr}{
        'new_account',
        'is_transfer_or_restore',
      };

    if ( %{$input_hr} ) {
        Carp::croak( 'Unknown option(s): ' . ( join q{ }, keys %{$input_hr} ) );
    }

    if ( $new_account && $is_restore ) {
        Carp::croak('new_account and is_transfer_or_restore options are mutually exclusive.');
    }

    return ( $new_account, $is_restore );
}

1;
