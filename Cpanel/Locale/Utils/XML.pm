package Cpanel::Locale::Utils::XML;

# cpanel - Cpanel/Locale/Utils/XML.pm              Copyright 2022 cPanel, L.L.C.
#                                                           All rights reserved.
# copyright@cpanel.net                                         http://cpanel.net
# This code is subject to the cPanel license. Unauthorized copying is prohibited

use cPstrict;

use Cpanel::CPAN::Locale::Maketext::Utils::Phrase ();
use Cpanel::DataStore                             ();
use Cpanel::FileUtils::TouchFile                  ();
use Cpanel::Locale                                ();
use Cpanel::Locale::Utils::Export                 ();
use Cpanel::Locale::Utils::MkDB                   ();
use Cpanel::Locale::Utils::Paths                  ();
use Cpanel::Locale::Utils::Queue                  ();
use Cpanel::Locale::Utils::XLIFF                  ();
use Cpanel::SafeDir::MK                           ();

use XML::Dumper ();
use XML::LibXML ();    ## no critic qw(PreferredModules)
use Encode      ();

my $lh;

sub get_data_struct_from_xml_file {
    my ( $xml_file, $error_sr ) = @_;

    my $dom = eval {
        XML::LibXML->load_xml(
            location        => $xml_file,
            encoding        => 'utf-8',
            no_blanks       => 1,
            ext_ent_handler => sub { },
            expand_entities => 0,
            load_ext_dtd    => 0,
        );
    };

    if ($@) {
        ${$error_sr} = "Could not load XML file '$xml_file': $@";
        return;
    }

    my $struct = deserialize_xml( $dom->findnodes('/perldata') );

    my %req_keys = (
        'struct_version'           => 1,
        'data_collection_started'  => 1,
        'locale'                   => 1,
        'payload'                  => 1,
        'data_collection_finished' => 1,
    );

    if ( ref $struct ne 'HASH' || map { exists $req_keys{$_} ? () : $_ } keys %{$struct} ) {
        ${$error_sr} = "XML file ($xml_file) does not appear to be a locale format XML file.";
        return;
    }

    return $struct;
}

# This deserializes perl object data from XML generated by XML::Dumper.
# This expects an XML::LibXML node object.
# This is not meant to be used for anything other than the Locale "Dumper" format.

sub deserialize_xml {
    my ($node) = @_;

    # If the node is not defined, this is unlikely to be valid data.
    if ( !defined($node) ) {
        return undef;
    }

    # Process a hashref, memebers are child "item" nodes.
    if ( my $hrs = $node->findnodes('./hashref') ) {
        my %hash;
        for my $item ( $hrs->[0]->findnodes('./item') ) {
            $hash{ Encode::encode( "utf8", $item->getAttribute('key') ) } = deserialize_xml($item);
        }
        return \%hash;
    }

    # Process an arrayref, memebers are child "item" nodes.
    if ( my $ars = $node->findnodes('./arrayref') ) {
        my @array;
        for my $item ( $ars->[0]->findnodes('./item') ) {
            $array[ $item->getAttribute('key') ] = deserialize_xml($item);
        }
        return \@array;
    }

    # If we have "defined" attribute, set to "false", then this is an "undef" value.
    if ( defined( $node->getAttribute('defined') ) && $node->getAttribute('defined') eq 'false' ) {
        return undef;
    }

    # If a Text child node exists, then we return the scalar data.
    # If no child node exists, then we return an empty string.
    my ($text) = $node->childNodes();
    return ( defined($text) && ref($text) eq "XML::LibXML::Text" ) ? Encode::encode( "utf8", $text->data ) : '';
}

sub save_data_struct_to_xml_file {
    my ( $xml_file, $struct, $error_sr, $options ) = @_;

    $options ||= {};

    if ( $xml_file =~ m/\.xml$/ ) {

        # passing as filename does not seem to have the same effect (legacy files break the wellformedness ...)
        if ( my $xml = XML::Dumper::pl2xml($struct) ) {

            # DO NOT OPEN WITH utf8 layer !!
            if ( open my $xml_out, '>', $xml_file ) {
                print {$xml_out} $xml;
                close $xml_out;
                return 1;
            }
            else {
                ${$error_sr} = "Could not save XML file '$xml_file': $!";
                return;
            }

            return 1;
        }
        else {
            ${$error_sr} = "Could not save XML file '$xml_file': $!";
            return;
        }
    }
    elsif ( $xml_file =~ m/\.xlf$/ ) {
        if ( open my $xml_fh, '>', $xml_file ) {
            my $xobj = Cpanel::Locale::Utils::XLIFF->new( $xml_fh, $options );

            # Turn $struct into generate_xliff_doc_for_phrases() arguments
            my @phrases;
            my $conf_hr = {
                'original'              => 'cPanel Locale Export',
                'source-language'       => 'en',
                'target-language'       => $struct->{'locale'},
                'arbitrary_key_mapping' => {},
                'target_map'            => {},                        # PBI 4390
                'target_note'           => 'cPanel Locale Export',    # PBI 4390
            };

            # use $struct to build @phrases, $conf_hr->{'arbitrary_key_mapping'}, and $conf_hr->{'target_map'}

            $lh ||= Cpanel::Locale->get_handle();

            my $no_fallback = $options->{'no-fallback'};

            # we are flattening the data so do / and x3 only for now, see PBI 4391
          THEME:
            for my $theme ( '/', 'x3' ) {
                my @loc_files  = grep m{/\Q$struct->{'locale'}\E\.\S+$}, sort keys %{ $struct->{'payload'}{$theme} };
                my @base_files = grep m{/en.\S+$},                       sort keys %{ $struct->{'payload'}{$theme} };
                my @files      = ( @loc_files, @base_files );

              FILE:
                for my $file (

                    # not anchored: /var/cpanel/locale.local/… as well as ….local
                    # same effect by different means would be acceptable also
                    grep( m/\.local/,  @files ),
                    grep( !m/\.local/, @files )
                ) {
                    next if $struct->{'payload'}{$theme}{$file}{'is_legacy'};

                  KEY:
                    for my $key ( sort keys %{ $struct->{'payload'}{$theme}{$file}{'data'} } ) {

                        next if index( $key, '__' ) == 0;
                        next if exists $conf_hr->{'target_map'}{$key};    # skip it if we've seen it alread since we're looping in precedence

                        # Determine the values we're interested in:
                        my $value = $struct->{'payload'}{$theme}{$file}{'data'}{$key};
                        my $arb_val;

                        if ( Cpanel::Locale::Utils::Queue::lexicon_key_is_arbitrary($key) ) {
                            $arb_val = Cpanel::Locale::Utils::Queue::get_lexicon_key_en_value($key);
                        }

                        # Validate that the values compile:
                        local $SIG{'__DIE__'};
                        eval {
                            $lh->_compile($value);
                            $lh->_compile($arb_val) if defined $arb_val;

                            # This will catch 'ambiguous at best' oddities that _compile() will ignore.
                            #   e.g. no opening [ and an unescaped closing ]
                            Cpanel::CPAN::Locale::Maketext::Utils::Phrase::phrase2struct($value);
                            Cpanel::CPAN::Locale::Maketext::Utils::Phrase::phrase2struct($arb_val) if defined $arb_val;
                        };
                        if ($@) {
                            my $copy = $@;
                            $copy =~ s/via Cpanel::Locale.*$//;
                            $copy =~ s/at \S+ line \d+\s*$//;
                            $copy =~ s/\s+$/\n/;
                            $copy =~ s/\n/\n\t       /g;

                            ${$error_sr} .= "Ignoring key due to syntax error:\n\tKey: $key\n\tValue: $value\n\tError: $copy\n";
                            next;
                        }

                        # Add it to the data structures:
                        push @phrases, $key;
                        if ( defined $arb_val ) {
                            $conf_hr->{'target_map'}{$arb_val}        = $value || ( $no_fallback ? '' : $key );
                            $conf_hr->{'arbitrary_key_mapping'}{$key} = $arb_val;
                        }
                        else {
                            $conf_hr->{'target_map'}{$key} = $value || ( $no_fallback ? '' : $key );
                        }
                    }
                }
            }

            return 1 if $xobj->generate_xliff_doc_for_phrases( @phrases, $conf_hr );

            ${$error_sr} .= "Could not save XML file '$xml_file': $!";
            return;
        }
    }
    else {
        ${$error_sr} = "File must end in .xlf or .xml";
        return;
    }
}

sub locale_to_xml {
    my ( $xml_file, $locale, $error_sr, $options ) = @_;

    my $struct = Cpanel::Locale::Utils::Export::locale_to_struct($locale);

    if ( $options->{'no-brackets'} ) {
        filter_brackets($struct);
    }

    return save_data_struct_to_xml_file( $xml_file, $struct, $error_sr, $options );
}

sub filter_brackets {
    my ($struct) = @_;

    foreach my $theme ( keys %{ $struct->{'payload'} } ) {
        foreach my $file ( keys %{ $struct->{'payload'}{$theme} } ) {
            foreach my $key ( keys %{ $struct->{'payload'}{$theme}{$file}{'data'} } ) {
                if ( $key =~ m/\[+/ ) {
                    delete $struct->{'payload'}{$theme}{$file}{'data'}{$key};
                }
            }
        }
    }

    return;
}

sub xml_to_locale {
    my ( $xml_file, $error_sr ) = @_;
    if ( $xml_file =~ /\.xml\z/s ) {
        return Cpanel::Locale::Utils::XML::xml_file_to_locale( $xml_file, \$error_sr );
    }
    elsif ( $xml_file =~ /\.xlf\z/s ) {
        return Cpanel::Locale::Utils::XML::xlf_file_to_locale( $xml_file, \$error_sr );
    }

    ${$error_sr} = "File must end in .xlf or .xml";
    return;
}

sub xml_file_to_locale {
    my ( $xml_file, $error_sr ) = @_;
    my $struct = get_data_struct_from_xml_file( $xml_file, $error_sr ) || return;

    for my $theme ( sort keys %{ $struct->{'payload'} } ) {
        next if $theme ne '/' && -l "/usr/local/cpanel/base/frontend/$theme";

        for my $file ( sort keys %{ $struct->{'payload'}{$theme} } ) {
            next if -l $file;

            if ( !_validate_locale_file_name($file) ) {
                die "Invalid filename in uploaded XML: $file";
            }

            my ( $head, @pieces ) = reverse( split( /\//, $file ) );
            my $directory = join( '/', reverse(@pieces) );
            if ( !-d $directory ) {
                if ( !Cpanel::SafeDir::MK::safemkdir($directory) ) {
                    ${$error_sr} .= "Could not make directory '$directory': $!";
                    return;
                }
            }

            if ( -e $file ) {
                my %save = %{ $struct->{'payload'}{$theme}{$file}{'is_legacy'} ? Cpanel::Locale::Utils::MkDB::get_hash_of_legacy_file_or_its_cache($file) : Cpanel::DataStore::fetch_ref($file); };

                if ( $file =~ m/\.local/ ) {

                    # merge w/ preference to $struct's keys
                    for my $key ( keys %{ $struct->{'payload'}{$theme}{$file}{'data'} } ) {
                        $save{$key} = $struct->{'payload'}{$theme}{$file}{'data'}{$key};
                    }
                }
                else {

                    # merge w/ pref toward existing FS file's keys
                    for my $key ( keys %{ $struct->{'payload'}{$theme}{$file}{'data'} } ) {
                        if ( !exists $save{$key} ) {
                            $save{$key} = $struct->{'payload'}{$theme}{$file}{'data'}{$key};
                        }
                    }

                }

                if ( $struct->{'payload'}{$theme}{$file}{'is_legacy'} ) {
                    if ( open my $fh, '>', $file ) {
                        for my $leg_key ( keys %save ) {
                            print {$fh} "$leg_key=$save{$leg_key}\n";
                        }
                        close $fh;
                    }
                    else {
                        ${$error_sr} .= "Could not open '$file' for writing: $!\n";
                    }
                }
                else {
                    if ( !Cpanel::DataStore::store_ref( $file, \%save ) ) {
                        ${$error_sr} .= "Could not save YAML file '$file': $!\n";
                    }
                }

            }
            else {
                if ( $struct->{'payload'}{$theme}{$file}{'is_legacy'} ) {
                    if ( open my $fh, '>', $file ) {
                        for my $leg_key ( keys %{ $struct->{'payload'}{$theme}{$file}{'data'} } ) {
                            print {$fh} "$leg_key=$struct->{'payload'}{$theme}{$file}{'data'}{$leg_key}\n";
                        }
                        close $fh;
                    }
                    else {
                        ${$error_sr} .= "Could not open '$file' for writing: $!\n";
                    }
                }
                else {
                    if ( !Cpanel::DataStore::store_ref( $file, $struct->{'payload'}{$theme}{$file}{'data'} ) ) {
                        ${$error_sr} .= "Could not save YAML file '$file': $!\n";
                    }
                }
            }
        }
    }

    return $struct->{'locale'};
}

sub xlf_file_to_locale {
    my ( $xml_file, $error_sr ) = @_;

    if ( open my $xml_fh, '<', $xml_file ) {
        my $xliff = do { local $/; <$xml_fh> };
        close $xml_fh;

        my $xobj = Cpanel::Locale::Utils::XLIFF->new();

        my $imp_loc    = $xobj->get_target_locale_of_xliff_doc($xliff);
        my $target_loc = ( index( $imp_loc, 'i_' ) == 0 ) ? $xobj->get_source_locale_of_xliff_doc($xliff) : $imp_loc;

        $lh ||= Cpanel::Locale->get_handle();

        if ( my $loc = ref( $lh->get_locales_obj() )->new($target_loc) ) {    # we do a ref() since new() needs a class (rt 80247)
            $imp_loc = ( index( $imp_loc, 'i_' ) == 0 ) ? $imp_loc : $loc->get_locale();
        }
        else {
            ${$error_sr} = "Sorry, the locale “$imp_loc” is not valid.";
            return;
        }

        my $local_edit_file = Cpanel::Locale::Utils::Paths::get_locale_yaml_local_root() . "/$imp_loc.yaml";
        my $lex_hr          = $xobj->generate_lexicon_from_xliff_doc($xliff);

        if ( !%{$lex_hr} ) {
            ${$error_sr} = "The XLIFF data contains no phrase data.";
            return;
        }

        #  put $lex_hr into $local_edit_file
        if (
            Cpanel::DataStore::edit_datastore(
                $local_edit_file,
                sub {
                    my ($hr) = @_;
                    my %copy = %{$hr};
                    %{$hr} = (
                        %copy,
                        %{$lex_hr},
                    );
                    return 1;    # true means to save the new ref to disk
                }
            )
        ) {

            # The main lexicon file must exist, otherwise the local one will not be discovered.
            my $main_lex_file = Cpanel::Locale::Utils::Paths::get_locale_yaml_root() . "/$imp_loc.yaml";
            if ( -f $main_lex_file ) {

                # Touch the main lexicon file so that other processes know to reload it; when
                # they do, they should also load the local lexicon file that was just edited.
                Cpanel::FileUtils::TouchFile::touchfile($main_lex_file);
            }
            else {

                # The main lexicon file does not exist, but we can't simply touch it because
                # other functions assume that it is a properly formatted YAML file.  Thus, we
                # create an "empty" YAML file.  The 'sub {1}' means, "write the file".
                if ( !Cpanel::DataStore::edit_datastore( $main_lex_file, sub { 1 } ) ) {
                    ${$error_sr} = "Could not ensure “$main_lex_file”: $!";
                    return;
                }
            }
        }
        else {
            ${$error_sr} = "Could not save data to “$local_edit_file”: $!";
            return;
        }

        return $imp_loc;
    }
    else {
        ${$error_sr} = "Could not open “$xml_file” for reading: $!\n";
        return;
    }
}

my ( $valid_locale_paths_re, $wh_class );

sub _validate_locale_file_name {
    my $file = shift;

    $valid_locale_paths_re ||= join '|', Cpanel::Locale::Utils::Paths::get_locale_yaml_root(), Cpanel::Locale::Utils::Paths::get_locale_yaml_local_root(), Cpanel::Locale::Utils::Paths::get_legacy_lang_root(), Cpanel::Locale::Utils::Paths::get_i_locales_config_path();

    $wh_class ||= '[a-zA-Z0-9_\-]';

    return 1 if $file =~ m{^ (?: $valid_locale_paths_re ) / (?: $wh_class +? [.]? )+ $ }ox;

    return 1 if $file =~ m{^/usr/local/cpanel/base/frontend/
                                 (?: $wh_class + | / ) /
                                 (?: lang | locale ) /
                                 (?: $wh_class +? [.]? )+$}ox;

    return 1 if $file =~ m{^/usr/local/cpanel/locale/queue/(?: $wh_class +? [./]? )+$}ox;

    return 1 if $file =~ m{^/usr/local/cpanel/modules-install/ $wh_class (?: $wh_class +? [./]? )+$}ox;

    return;
}

1;
